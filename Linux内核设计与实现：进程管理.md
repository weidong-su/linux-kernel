# 进程和线程
进程：处于执行期的程序，通常还包含了其他资源，如打开的文件，挂起的信号，内核内部资源，处理器状态，一个具有内存映射的内存地址空间以及一个及多个的执行线程，也包含了存放全局变量的数据段等。即进程就是正在执行的程序的实时结果。
线程：进程中的活动对象。每个线程具有独立的程序计数器、进程栈和进程寄存器。Linux中的线程实现非常特别：并没有特别区分线程和进程，线程只是一种特殊的进程（共享地址空间等资源）。

# 进程描述符
内核把进程的列表存放在任务队列task_list双向链表中，每一个task_list中的链表节点是一个task_struct 进程描述符。结构如下：
```
struct task_struct {
    unsigned long state;
    pid_t pid;
    int prio;
    struct task_struct* parent
....
}
```
主要包含进程的状态、打开的文件、地址空间等等。
分配：
在内核的内存栈底部（或者顶部）创建一个thread_info结构，其中包含指向进程描述符task_struct的指针

# 进程的状态
进程描述符task_struct中的state描述了进程的状态，具体如下
![201208201741318168](https://github.com/weidong-su/leetcode/assets/42209591/2ed056d8-4618-4c65-acc4-23e5c5c4946b)

# 进程的创建
Linux进程不是无中生有spawn产生的，是复制当前进程来创建一个子进程。主要分为两步：fork()和exec()
fork()：复制当前进程来创建一个子进程，子进程和父进程的区别主要在于pid，ppid，一些资源和统计量。
exec(): 读取可执行文件，将其载入内存运行。
写时拷贝：fork()不会复制父进程的所有资源，只有当需要写入数据时，才会复制数据，让每个进程拥有各自的拷贝。即资源的复制只有在需要写入的时候才进行，在这之前都是以只读的方式共享。

创建流程：（fork调用clone, clone调用do_fork）
1. 调用dup_task_struct() 为新进程创建内存栈、thread_info和task_struct结构。其中的内容和父进程一样。
2. check新进程（进程个数是否超出上限）。
3. 清理新进程的信息（如pid=0），使之与父进程区分开。
4. 设置新进程的state为TASK_UNINTERRUPTIBLE，保证它不会投入运行。
5. 设置新进程的flags
6. 调用alloc_pid()为新进程分配一个有效的pid
7. 根据clone的参数，拷贝或共享 父进程的资源
8. 做一些扫尾工作，返回指向新进程的指针。
创建进程的fork() 实际上最终会调用clone()函数。
创建线程的步骤和创建进程一样，只不过传给clone的参数不同。从内核的角度看，线程不过是与其他进程共享一些资源的进程。

创建进程：fork()就相当于clone(SIGCHLD, 0)；其含义是：clone(SIGCHLD, 0)的含义是创建一个新的进程，并指定当子进程终止时父进程会收到一个SIGCHLD信号，但没有传递任何参数给子进程。
创建线程：创建一个与父进程共享地址空间、共享文件资源、共享打开文件和信号处理程序的进程：
clone(CLONE_VM|CLONE_FS|CLONE_FILES|CLONE_SIGHAND, 0)

## 内核线程
在内核中创建的内核线程与普通的进程之间还有个主要区别在于：内核线程没有独立的地址空间，它们只能在内核空间运行。
这与之前提到的Linux内核是个单内核有关。

# 进程的终止
与进程的创建一样，进程的终止也有很多步骤。
简单来说：释放内存、释放拥有的资源、设置僵尸状态、通知父进程、重新调度。

子进程上的操作：（do_exit）
1. 设置进程的标志成员flags为PF_EXITING
2. 删除内核定时器，确保没有定时器在运行
3. 释放进程占用的mm_struct，如果没有进程共享这个地址就直接释放
4. 若进程在排队等待IPC信号，则离开队列
5. 释放进程占用的文件描述符和文件系统资源
6. 设置返回值为task_strcuct的exit_code
7. 调用exit_notify()通知父进程，将状态设置为EXIT_ZOMBIE
8. 调用schedule()重新调度新的进程
子进程进入EXIT_ZOMBIE后，就不可运行了，但它本身占用的内存还没有释放。比如创建时分配的内核栈、thread_info、task_struct结构需要父进程清理。

父进程上的操作：（release_task）
父进程在收到子进程发送的exit_notify()信号，将子进程的进程描述符和进程独占资源全部删除。
从上面的步骤可以看出，必须要确保每个子进程都有父进程，如果父进程在子进程结束之前就已经结束了会怎么样呢？
子进程在调用exit_notify()时已经考虑到了这点。
如果父进程在子进程结束之前就已经结束了，那么子进程在退出时，exit_notify()函数会先调用forget_original_parent()，然后再调用find_new_reaper()来寻找新的父进程。find_new_reaper会在当前线程组中寻找一个线程，若不存在，在将init线程作为父进程。
