# 什么是调度
调度程序，说起来很简单，功能就是：
+ 决定哪个进程投入运行，那些进程等待
+ 决定每个进程运行多长时间

# Linux进程调度
完全公平调度算法 CFS（Completely Fair Scheduler）
## 进程优先级
#### nice值
nice值的范围是-20~+19，nice值越低，优先级越高。nice=-20的进程优先级最高
#### 实时优先级
实时优先级的范围是0~99，实时优先级越高，进程优先优先级就越高。
实时优先级一般是对响应时间要求比较高的进程，因此系统中有实时优先级的进程处于运行队列中，它们会抢占一般进程的运行时间。
#### 哪个优先级更优先
实时优先级 > nice值
#### 同时有两个优先级怎么办
一个进程不可能有2个优先级。一个进程有了实时优先级就没有Nice值，有了Nice值就没有实时优先级。
下面的命令可以查看进程的实时优先级和nice值
```
ps -eo state,uid,pid,ppid,rtprio,ni,time,comm
```
## 时间片
有了优先级，可以决定谁先运行了。但是对于调度程序来说，并不是运行一次就结束了，还必须知道间隔多久进行下次调度。
时间片是一个数值，表示一个进程在被抢占前持续运行的时间。
时间片大小的设置并不简单，设大了，会导致系统交互响应变慢，设小了，进程频繁切换会增大进程切换带来的处理器耗时。
默认的时间片一般是10ms

## 公平调度原理
CFS允许每个进程运行一段时间，循环流转，选择运行时间最少的进程作为下一个运行的进程。nice值，作为进程占用CPU运行比的权重。更小的nice值的进程获取更高的处理器使用权重.
## 调度实现
1. 计算每个进程的vruntime
virtual run time 虚拟运行时间 是每个进程按nice值加权后的运行时间。越小的nice值，vruntime增长越缓慢。
2. 选择具有vruntime最小的进程投入运行
CFS用红黑树来组织可运行进程队列，并利用其找到最小vruntime的进程（最左节点）
3. 更新vruntime，转入步骤2
Linux为了能快速的找到具有最小vruntime，将所有的进程的存储在一个红黑树中。这样树的最左边的叶子节点就是具有最小vruntime的进程，新的进程加入或有旧的进程退出时都会更新这棵树。

### 举个🌰
比如有三个进程 A(NI=1), B (NI= 1/ 3), C(NI= 1/ 6)，在CFS中，分别占用CPU时间的百分比为 A(10%), B(30%), C(60%)
1. 比如先运行C，则10ms后，几个进程的vruntime为 A (vr=0), B(vr=0), C(vr=10ms / 6)
2. 下次调度只能选择A和B（每次选择最小的vruntime进程），比如选择了A，运行了10ms后：A (vr=10ms / 1), B(vr=0), C(vr=10ms / 6)
3. 再选择进程B，运行10ms后：A (vr=10ms / 1), B(vr= 10ms/ 3), C(vr=10ms / 6)
4. 此时再比较三者的vruntime，会选择C。
从上面的🌰可以看出，进程的nice值越小，vruntime增长的越缓慢，占用CPU的时间越多。

## 调度器
其实Linux上的调度器是以模块方式提供的，每个调度器有不同的优先级，所以可以同时存在多种调度算法。
每个进程可以选择自己的调度器，Linux调度时，首先按调度器的优先级选择一个调度器，再选择这个调度器下的进程。

进度调度的入口是函数schedule()，会找到**优先级最高**的调度器——后者会维护一个可运行进程队列，需要问后者选择**最高优先级**的进程
